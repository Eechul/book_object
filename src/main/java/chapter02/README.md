# Chator02 - 객체지향 프로그래밍

1. 영화 예매 시스템
   * [예제코드](https://github.com/Eechul/book_object/tree/main/src/main/java/chapter02/movie)
   * 요구사항 살펴보기
     * 영화 예매 시스템을 이용해 쉽고 빠르게 보고 싶은 영화를 예매할 수 있다.
     * 용어정리1 - 영화와 상영의 차이점
     * 용어정리2 - **할인 조건(discount condition)** 과 **할인 정책(discount policy)**
       * 할인 조건은 순서와 기간 조건으로 나뉨. 
         * 순서 조건 - 상영 순번을 통한 할인
         * 기간 조건 - 요일, 시작시간, 종료 시간 세 부분으로 해당 기간 안에 포함 되면 요금을 할인
       * 할인 정책은 금액 할인 정책과 비율 할인 정책으로 나뉨
       * 영화별로 하나의 할인 정책, 또는 안할 수 있다.
       * 할인 조건은 다수로 할당 가능하다.
       * 할인 프로세스는 먼저 할인 조건을 충족한다면, 할인 정책이 시행된다.
2. 객체지향 프로그래밍을 향해
   * 객체지향 언어에서 제일 처음 고려하는건 '클래스' 일것이다. 하지만 객체지향은 객체에 초점을 맞춰야한다.
     * 첫째, 어떤 클래스가 필요한지 고민하기 전에, 어떤 객체들이 있을지 고민하라
     * 둘째, 객체는 홀로 존재하지 않고 다른 객체와 도움을 주고 받고, 의존하며 협력한다. 객체간의 공동체가 형성되는 것이다.
   * 도메인의 구조를 따르는 프로그램 구조
     * **도메인(domain)**: 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
     * 객체지향 페러다임이 강력한 이유: 초기 단계(요구사항 분석)부터 마지막 단계(구현)까지 동일한 추상화 기법을 사용할 수 있기 때문이다.
     * 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다.
   * 클래스 구현하기
     * 도메인을 통해 클래스 구조가 잡혔다면 적절한 프로그래밍 언어로 구현해야 한다.
     * [Screening 클래스 예제](https://github.com/Eechul/book_object/blob/main/src/main/java/chapter02/movie/Screening.java)
     * 왜 인스턴스 변수의 가시성은 private 이고 메서드의 가시성은 public 일까?
       * 설계할때 어떤 부분을 외부로 노출할지, 어떤 부분을 감출지 결정하는데, 외부에서 객체 속성(내부 상태)에 직접적으로 접근할 수 없게 막고, 적절한 public 메서드를 사용하여 내부 상태를 변경 하게끔 한다.
       * 이렇게 클래스 내부와 외부를 나누는 이유는 객체의 자율성을 보장하기 위해서다. 더 중요한 이유는 프로그래머에게 구현의 자유를 제공한다.
     * 자율적인 객체
       * 첫번째 객체는 **상태(state)** 와 **행동(behavior)**을 함께 가지는 복합적인 존재이다.
       * 두번째 객체는 스스로 판단하고 행동하는 자율적인 존재이다.
       * 데이터와 기능을 객체 내부로 함께 묶는것을 **캡슐화** 라고 한다.
       * 외부에서 접근을 통제할 수 있는 접근 제어(access control) 메커니즘은 객체를 더 자율적인 존재로 만들기 위함이다.
         * 자율적인 존재가 되려면 외부의 간섭을 최소화 해야한다. 스스로 결정하게 해야한다.
       * 캡슐화와 접근제어는 객체를 두 부분으로 나눈다. 퍼블릭 인터페이스, 구현
       * 퍼블릭 인터페이스(public interface): 외부에서 접근 가능한 부분
       * 구현(implementation): 내부에서만 접근 가능한 부분
     * 프로그래머의 자유
       * 프로그래머 역할운 클래스 작성자(class creator), 클라이언트 프로그래머(client programmer)로 구분하면 유용하다.
       * 클래스 작성자: 새로운 타입을 프로그램에 추가
       * 클라이언트 프로그래머: 클래스 작성자가 추가한 데이터 타입을 사용
       * 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨야 한다. 이렇게 접근을 제어함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고 내부구현을 변경할 수 있다. 이를 구현 은닉(implementation hidding) 이라고 부른다.
       * 구현 은닉의 장점은 클라이언트 프로그래머는 내부구현은 무시하고 인터페이스만 알고 있어도 클래스를 사용할 수 있어 지식의 양을 줄일 수 있다. 그리고 클래스 작성자는 내부구현을 변경하는데 용이하다.
   * 협력하는 객체들의 공동체
     * 상영(Screening) 객체의 예매(reserve) 메서드 부터 시작된 영화 예매는 상영, 영화(Movie), 예매(Reservation) 인스턴스 끼리 어떤 기능(영화 예매)을 위해 서로 메서드를 호출하며 상호작용을 한다. 이것이 **협력(Collaboration)** 이다
   * 협력에 관한 짧은 이야기
     * 객체는 내부 상태를 외부로 알리는 수단으로 퍼블릭 인터페이스를 사용한다. 
     * 이 퍼블릭 인터페이스를 통해 객체와 객체간의 행동 요청(request)과 요청 받은 객체의 자율적인 응답(response)이 가능하다.
     * 객체간의 상호작용은 **메세지를 전송(send a message)** 하는것 뿐이다. 그 요청을 받는 객체는 메세지를 **수신(receive a message)** 했다고 한다.
     * 메세지를 수신한 객체는 자율적으로 메세지를 처리할 방법을 결정한다. 이 수단을 메서드(method) 라고 부른다.
     * 메시지와 메서드는 다르다. 코드에선 상영은 영화의 calculateMoiveFee 메서드를 호출하지만, 사실 '영화에게 calculateMoiveFee 메세지를 전송한다' 라고 말하는것이 적절. 상영은 영화에 calculateMoiveFee 메서드가 있는지도 모른다고 이해하는게 맞다.
3. 할인 요금 구하기
   * 할인 요금 계산을 위한 협력 시작하기
     * 영화 클래스의 `calculateMovieFree` 메서드는 할인 정책(DiscountPolicy)에 따라 영화요금을 계산하여 반환한다.
     * 그런데 이 메서드로만 봐선 할인 정책을 쓴다는 메세지만 전송한 것일 뿐 어떤 할인 정책을 썼는지 알 수 없다.
   * 할인 정책과 할인 조건
     * 할인 정책은 금액 할인 정책(AccountDiscountPolicy) 또는 비율 할인 정책(PercentDiscountPolicy)으로 구현될 것이고, 중복 코드로 묶어 추상화 했다는걸 알 수 있다.(추상클래스 사용)
     * 할인 정책에는 여러개의 할인 조건(DiscountCondition)이 존재한다. 할인 조건은 인터페이스로 선언되고, 순번 조건(SequenceDiscountCondition)과 시간 조건(PeriodDiscountCondition)으로 구현될 것이다.
4. 상속과 다형성
   * Movie 내부에 할인 정책을 선택하는 하는 코드가 없는데 어떻게 선택될까? 상속과 다형성을 알아야 한다.
   * 컴파일 시간 의존성과 실행 시간 의존성
     * 코드 상(시점)의 영화(컴파일 시간)와 실행 시점의 영화가 가지는 의존성 클래스가 다른걸 알 수 있다.
     * 컴파일 시점과 실행 시점의 의존성이 달라질때 단점은 코드 파악이 어려울 수 있다. 다만, 유연하고 확장 가능하다.
       * 의존성의 양면성을 잘 보여주는 예. 트레이드오프의 산물
   * 차이에 의한 프로그래밍
     * 그렇다면 코드 상에서 `DiscountPolicy` 였던 의존성이 실행 시점에서 `AmountDiscountPolicy`나 `PercentDiscountPolicy`로 의존성이 바뀔 수 있나? 상속이라는 방법 때문이다.
     * 상속은 자식이 부모의 특성(속성, 행동 등)을 물려 받으며 새로운 기능을 쉽고 빠르게 정의할 수 있다. -> 차이에 의한 프로그래밍(programming by diffence)
   * 상속과 인터페이스
     * 자식 클래스는 부모 클래스를 상속 받으면서 부모의 인터페이스 까지 물려 받아 사용할 수 있게 된다.
     * 컴파일러는 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다. -> 업캐스팅(upcasting)
   * 다형성
     * 앞에서도 말했지만, 메세지와 메서드는 다르다.
     * 영화는 `DiscountPolicy`의 인스턴스에게 `calculateMovieFree` **메세지**를 전송
     * 그럼 실행되는 메서드는 뭔가? 협력하는 객체의 클래스 마다 다를 것이다(AmountDiscount or PercentDiscount). -> 다형성
     * 다형성: **동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력**
     * 협력에 참여하는 객체도 같은 메세지(인터페이스)를 가지고 있어야 한다.
     * 메세지와 메서드를 실행 시점에서 바인딩 하는것: 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)
     * 컴파일 시점에 실행될 함수나 프로시저를 결정하는것: 초기 바인딩(early) 또는 정적 바인딩(static binding)
   * 인터페이스와 다형성
     * `DiscountPolicy`는 추상 클래스로 자식들이 인터페이스와 내부 구현을 같이 상속받았다. 반면 인터페이스만 공유 할 수도 있다. 자바의 인터페이스.
     * 할인 조건(`DiscountCondition`)이 인터페이스만을 가진 구조이다. 업캐스팅 적용 가능

